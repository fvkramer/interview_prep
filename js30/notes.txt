
1. Call Stack
  - single threaded single concurrent language
  - single call stack + heap + queueu
    - push onto call stack. when return, pop off
  - heap - objects are allocated in heap. unstructured region of memory.
        - memoery allocation to variables and objects happens here
  - queue - JS runtime contains message queue, list of messages to be processed and associated callback functions to execut

  Event Loop
    - blocking script - slow function keeps stack occupied/blocked
    - to stop async code from blocking stack, use asynchronous callbacks
      - run code and give it a callback function(does not block call stack)


  A. Javascript Runtime
    Call Stack            Heap

    function call         memory allocation

  B. Web APIs (browser provided)
    
  C. Callback Queue
      - Event Loop pushes from callback queue to JS runtime


2. Primitive Types
  - All JS numbers are floating point. 
    - encoded internally as 64 bit binary
    - sign occupies bit 63  (bit 0 means positive)
    - exponent bits 52 to 62 (contains digits of number)
    - fraction bits 0 to 51 (indicates where point is)

3. Value Types and Reference Types
  - Primitive Data Types passed by Value
    - Boolean, null, undefined, String, Number
  - Objects passed by reference
    - Array, Function, Object

  - Primitive passing by value means value does not change
  - Object passed by reference. variables don't actually have the object


  - Reassigning reference replaces old reference

  == and === used on reference-type variables. they check reference
  if they have same values but are distinct objects, comparison retruns false

  When equality operators comparing primitives, they simply check values
  So to compare two objects, easiest way is to turn them into strings and then compare the strings

  var arr1str = JSON.stringify(arr1);
  var arr2str = JSON.stringify(arr2);

  arr1str === arr2str  // true


  When passing arguments into functions, the values are copied over, so variable reassignment does not occur

  Pure Functions - do not affect anything in outside scope
      - does not affect any variables on outside
      - can make copy of object and return that. doesn't change the actual object

4. Implicit, Explicit, Nominal, Structuring, and Duck Typing

  - JS attempts to coerce value type to expected type

  Non-Numeric Values in Numeric Expressions
    - Strings
    - String with numeric operators turned to number
    - String with non numeric operators returns NaN

    - Except or '+'
      - if '+'
        string concatentation

  Javascript Object conversions result in [object Object]

  "name" + {}  //  'name[object Object]
  every JS object has a toString method that is called when coercion occurs

  Array objects

  toString() method on Arrays is like .join() without arguments
  concatenating a string with an array -> string + array.toString()

  Number(true) // 1
  Number(false) // 0
  Number("")  // 0 


  Always be explicit in comparisons

  NaN !== NaN
  ECMAScript 6 introduced NaN

  Number.isNaN

5. == vs ===

left one type converts. don't use unless you're an OG

6. Function Scope, Block Scope, Lexical Scope

  - scope "bubbles" and creates containers/buckets in which
    variables, functions declared
  - function based scope 

  - Principle of "Least Authority"
    - design API to expose only what is necessary
    - nest functions within a function to protect scope
    - private details should be kept private

  - Global "Namespaces" 
    - multiple libraries loaded into program can collide with each other if 
      internal/private functions and functions

    - such libraries create single variable declaration, object, in global scope that 
      encapsulates functionality. this object is then the 'namespace'


  - let allows declarations of variables in any arbitrary block of code
    - var and let should coexist.

  - try {} catch (err) {} block scoping


  Garbage Collection
    - anything declared in block scope is garbaged collected 
    - if declared in open scope, not garbage collected because things have closure

7. Expression vs Statement

{} + 1     // 1
{2} + 2    // 2
{2+2} + 3  // 3
{2+2} - 3  // -3

Expressions can act like statements. Statements cannot act like Expressions


Expressions are JS code that result in a SINGLE value.
Expressions don't change state

const assignedVariable = 2;
assignedVariable + 4   //expression
console.log(assignedVariable)  // 2

Statements perform actions and do things

if (true) {9+9}

above line is a statement but returns a value that canot be used

Function declaration is statement
function foo (func) {
  return func.name
}

Function expression is expression - anonymous function
console.log(foo(function () {} ))


**
When declaring function where JS expects value, it attempts
to treat is as value and throws and error

When declaring function at global level script(where not expecting value)
it results in function declaration

Converting Expressions to Statements

2+2 // expression statement
foo(); //expression statement

to convert expression to expression statement, use semicolon
2+2 expression
2+2; expression statement


With semi-colon, can chain multiple statements

const a; function foo() {}; const b = 2

Comma operator allows chaining multiple expressions, returning only last expression

console.log( (1+2,3,4) ) // 4


IIFE (Immediately Invoked Function Expressions)

*** read more about it


{} + 1 //1

{2} + 2 // 2

{2+2} + 3 // 3

{2+2} -3 // -3

Block statement is statement. whatever returned by block statement
coerced to 0


35. JS Tools 
  - Webpack, Bable, ESLint, Mocha, Karma, Grunt
